create user node project 

controller folder

1)errorcontroller.js

const AppError = require('../util/appError');


const handleCastError = err => {
    const message = `invalid ${err.path}:${err.value}.`
    return new AppError(message, 400)
}

const handleValidationErr = err => {
    const error = Object.values(err.errors).map(ele => ele.message);
    const message = `invalid input data ${error.join('. ')}`;
    return new AppError(message, 400);
}

const handelJwtError = err => new AppError('invalid token plz login again', 401);
const handleJwtExp = err => new AppError('token expired plz login again', 401);


const sendErrordev = (err, res) => {
    console.log('development error',err)
    res.status(err.statusCode).send({
        status: err.status,
        error: err,
        stack: err.stack,
        message: err.message
    });
}

const sendErrorProd = (err, res) => {
    console.log('error is comiing', err);
    // console.log(err.isOperational, 'hiiii');
    if (err.isOperational) {
        res.status(err.statusCode).send({
            status: err.status,
            message: err.message,
        });
    } else {
        res.status(500).send({
            status: 'error',
            message: 'something went wrong'
        })
    }
}


module.exports = (err, req, res, next) => {
    err.statusCode = err.statusCode || 500;
    err.status = err.status || 'error';

    if (process.env.NODE_ENV === 'development') {
        sendErrordev(err, res);

    } else
     if (process.env.NODE_ENV === 'production') {
        let error = { ...err };
        // console.log(err, 'hdhdgdgghjg')
        if (error.name == 'CastError') error = handleCastError(error);

        if (error.name == 'ValidationError') error = handleValidationErr(error);
        if (error.name == 'JsonWebTokenError') error = handelJwtError(error);
        if (error.name == 'TokenExpiredError') error = handleJwtExp(error);
        sendErrorProd(error, res);
    }

}



2)notificationcontroller.js

const { validationResult } = require('express-validator');
const catchAsync=require('../util/catchAsync');

const appError = require('../util/appError');

const notificationModel=require('../model/notificationModel');


exports.getNotification=catchAsync(async (req,res,next)=>{

const data=await notificationModel.find({receiver:req.user.id}).populate('sender').populate('post').sort({createdAt:-1});
         if(data.length){
             res.status(200).json({
                    message: 'success',
                    total:data.length,
                    data:data,
                    info:process.pid
                })
    }else{
       return next(new appError('no data found!!', 400));
    }


});


exports.markAsRead=catchAsync(async (req,res,next)=>{
                 let id = req.params.id;
        const notification=await notificationModel.findByIdAndUpdate(id,{ isRead: true });
        if (notification) {
        res.status(200).json({
            message: 'notification read',
            data: notification
        });
    } else {
        return next(new appError('notification is not present in database', 400));
    }


});



3)postcontroller.js


const postModel = require('../model/postModel');

const userModel = require('../model/userModel');

const multer = require('multer');

const { validationResult } = require('express-validator');

const appError = require('../util/appError');
const catchAsync = require('../util/catchAsync');

const notificationModel=require('../model/notificationModel');


exports.createPost = catchAsync(async (req, res, next) => {
    const error = validationResult(req);
    if (!error.isEmpty()) {
        // console.log("hiiiii",error.errors[0]?.msg)
        return next(new appError(error.errors[0]?.msg, 422));
    }

    req.body.creator = req.user.id;
    let post;
    post = await postModel.create(req.body);
    console.log(post, "posttttt");
    let user = await userModel.find({ id: req.user.id });
    console.log(user, "userrrrrrr");

    if (user) {
        user[0].post.push(post.id);
        user[0].save();
        res.status(201).json({
            message: 'success',
            data: "post created successfully!!!"
        })
    } else {
        return next(new appError('plz login you are not active right now', 400));
    }
});



exports.getAllpost = catchAsync(async (req, res, next) => {

    console.log(req.query.isOwnProfile,"req ownprofile",req.query.searchPost)
    console.log(req.user,"from get all post");
let postList;
let tag ;
if(req.query.searchPost){

   tag = req.query.searchPost.toLowerCase();
}
    if(req.query.isOwnProfile === 'true'){
        //   postList= await postModel.find({creator:req.user.id},{content:{ $regex :`/#${req.query.searchPost}\b/i`}});

                 let query = { creator: req.user.id };

                if (tag) {
                     query.content = { $regex: new RegExp(`#${tag}\\b`, 'i') };
                    }
                 postList = await postModel.find(query);
        //     postList = await postModel.find({
        //     creator: req.user.id,
        //     content: { $regex: new RegExp(`#${tag}\\b`, 'i') }
        // });
    }else{

        let query={
            $or: [
       { visibility: "public" },
       { 
         visibility: "private", 
         creator: { $in: [...req.user.following,req.user.id] }  // followedUsers = array of userIds whom current user follows
       }
     ]
       };

        if (tag) {
                     query.content = { $regex: new RegExp(`#${tag}\\b`, 'i') };
                    }


        // postList = await postModel.find();
         postList = await postModel.find(query);
        
    }
  if (!postList) {
        return next(new appError('no data found!!', 400));
    } else {
        res.status(200).json({
            message: 'success',
            data: postList,
        })
    }


});


exports.getSinglePost = catchAsync(async (req, res, next) => {
    let id = req.params.id;

    let postDetails = await postModel.findById(id).populate('creator');

    if (postDetails) {
        res.status(200).json({
            message: 'success',
            data: postDetails
        })
    } else {
        return next(new appError('Post is not present in database', 400));
    }
});


exports.deletePost = catchAsync(async (req, res, next) => {
    let id = req.params.id;
    // try {
    let post = await postModel.findByIdAndDelete(id);

    let user = await userModel.find({ id: req.user.id });
    if (user) {
        // user[0].post.push(post.id);
        user[0].post = user[0].post.filter(ele => ele != id);
        console.log(user, "usersssssss");

        user[0].save();
        res.status(201).json({
            message: 'success',
            data: "post deleted successfully!!!"
        })
    } else {
        return next(new appError('plz login you are not active right now', 400));
    }


});


exports.updatePost = catchAsync(async (req, res, next) => {
    let id = req.params.id;

    if (req.file) req.body.imageUrl = req.file.filename;
    const post = await postModel.findByIdAndUpdate(id, req.body);
    if (post) {
        res.status(200).json({
            message: 'post updated succeessfully!!!',
            data: post
        });
    } else {
        return next(new appError('post is not present in database', 400));
    }
});



exports.comment = catchAsync(async (req, res, next) => {
    let id = req.params.id;
    console.log(id, "idddd")
    let postDetails = await postModel.find({ id: id })
    if (!postDetails) {
        return next(new appError('post is not present in database', 400));
    } else {
        req.body.userId = req.user.id;
        console.log(postDetails[0].comments, "request body");
        
      if(req.body.context) { 
        postDetails[0].comments.push(req.body) 
    }
      else{
        console.log("into else part");
        
        
         postDetails[0].reactions.push(req.body)
        };
        postDetails[0].save();
        if(postDetails[0].creator !== req.user.id){
            console.log("hiijdhjdhsdhskdjshdjhjhdsjdh")
            await notificationModel.create({
                 sender: req.user.id,
            receiver: postDetails[0].creator,
            type: req.body.context ? 'comment' : 'like',
            post: postDetails[0]._id,
            })
        }
         console.log(postDetails,"postdetails")
        res.status(201).json({
            message: 'success',
            data: `${req.body.context ? 'Commented' : 'Like'} on post successfully!!!`
        })
    }
})




const multiStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'img')
    },
    filename: (req, file, cb) => {
        const ext = file.mimetype.split('/')[1].split('+')[0];
        // console.log(ext,"ext")
        cb(null, `user-${req.user.id}-${Date.now()}.${ext}`);
    }
});

// const multiStorage = multer.memoryStorage();

const multerFilter = (req, file, cb) => {
    if (file.mimetype.startsWith('image')) {
        cb(null, true)
    }
    else {
        cb(new appError('not a image file', 404), false)
    }
}

const upload = multer({
    storage: multiStorage,
    fileFilter: multerFilter
});

exports.uploadPostImage = upload.single('postImage');


4)storycontroller.js

const storyModel=require('../model/storyModel');
const { validationResult } = require('express-validator');
const catchAsync=require('../util/catchAsync');

const appError = require('../util/appError');


exports.createStory=catchAsync(async (req,res,next)=>{
      const error = validationResult(req);
        if (!error.isEmpty()) {
              // console.log("hiiiii",error.errors[0]?.msg)
              return next(new appError(error.errors[0]?.msg, 422));
          }
           req.body.userId = req.user.id;
           req.body.expiresAt= new Date(Date.now() + 24 * 60 * 60 * 1000);
           req.body.mediaUrl=req.file.path;
           const story=await storyModel.create(req.body);
          if (story) {
                  res.status(201).json({
                      message: 'story uploaded !!!',
                      data: story
                  });
              } else {
                  return next(new appError('something went wrong', 400));
              }
})


exports.getAllStory=catchAsync(async (req,res,next)=>{

    const data= await storyModel.find({ expiresAt: { $gt: new Date() } }).populate('userId')
    if(data){
             res.status(200).json({
                    message: 'success',
                    total:data.length,
                    data:data,
                    info:process.pid
                })
    }

})




5)templatecontroller.js

const templateModel=require('../model/templateModel');

const { validationResult } = require('express-validator');
const fs=require('fs')
const csv = require('csv-parser');
const appError=require('../util/appError')
const catchAsync=require('../util/catchAsync');
const get_ip = require('ipware')().get_ip;
const multer=require('multer');
const Joi = require('joi');

// const redis=require('../util/redisconnection');


const multiStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'public')
    },
    filename: (req, file, cb) => {
        const ext = file.mimetype.split('/')[1];
        cb(null, `template.${ext}`);
    }
});


const multerFilter = (req, file, cb) => {
    if (file.mimetype == 'text/csv') { // checking the MIME type of the uploaded file
        cb(null, true);
    } else {
        cb(new appError('Please Upload Proper CSV file', 400), false);
    }
}

const upload = multer({
    storage: multiStorage,
    fileFilter: multerFilter

});

exports.uploadFile = upload.single('File');

let results = [];

exports.createTemplate = catchAsync(async (req, res, next) => {
    // console.log(req, "req");

    results = [];
    fs.createReadStream(req.file.path)
        .pipe(csv({}))
        .on('data', (data) => {
            results.push(data);

        })
        .on('end', async () => {
           
            res.status(201).send({ message: "All Templates Created Successfully!" });
            // console.log(results)
            for (let i = 0; i < results.length; i++) {
                console.log(results[i],"result");
                
                let finalObj = {
                    username: results[i].username,
                    system_ip: get_ip(req).clientIp,
                    bot_name: results[i].bot_name,
                    name: results[i].name,
                    variables: results[i].variables ? results[i].variables.toString().split(",") : [],
                    category: results[i].category ? results[i].category : "",
                    status: results[i].status ? results[i].status : ""
                }

                if (results[i].sub_type == 'text') {
                    let newobj = {};
                    Object.keys(results[i]).forEach((ele) => {
                        ele = ele.toString().trim();
                        if (ele.split("_")[0] === "suggestion") newobj[ele] = results[i][ele]
                    });

                    let SuggestionArr = [];
                    Array(11).fill(1).forEach((ele, idx) => {
                        let innerObj = {};
                        let currentFields = Object.keys(newobj).filter(key => key.includes(idx + 1));
                        if (currentFields.length) {
                            currentFields.forEach(innerEle => {
                                innerObj[innerEle.slice(innerEle.lastIndexOf("_") + 1)] = newobj[innerEle]
                            });
                            SuggestionArr.push(innerObj)
                        }
                    });

                    SuggestionArr = SuggestionArr.filter(ele => Object.keys(ele).length && Object.values(ele).every(key => key));  // Removing empty {} and pushed in [] 

                    finalObj["payload"] = {
                        "sub_type": results[i].sub_type ? results[i].sub_type : "",
                        "data": [
                            {
                                "text": results[i].text ? results[i].text : "",
                                "suggestions": SuggestionArr.length ? SuggestionArr : []
                            }
                        ]
                    }

                    // console.log("TEXT", JSON.stringify(finalObj))


                }
                else if (results[i].sub_type == 'rich_card') {

                    let newobj = {};
                    Object.keys(results[i]).forEach((ele) => {
                        ele = ele.toString().trim();
                        if (ele.split("_")[0] === "suggestion") newobj[ele] = results[i][ele]
                    });


                    let SuggestionArr = [];
                    Array(4).fill(1).forEach((ele, idx) => {
                        let innerObj = {};
                        let currentFields = Object.keys(newobj).filter(key => key.includes(idx + 1));
                        if (currentFields.length) {
                            currentFields.forEach(innerEle => {
                                innerObj[innerEle.slice(innerEle.lastIndexOf("_") + 1)] = newobj[innerEle]
                            });
                            SuggestionArr.push(innerObj)
                        }
                    });

                    SuggestionArr = SuggestionArr.filter(ele => Object.keys(ele).length && Object.values(ele).every(key => key));  // Removing empty {} and pushed in [] 


                    finalObj["payload"] = {
                        "sub_type": results[i].sub_type ? results[i].sub_type : "",
                        "data": [
                            {
                                "title": results[i].rich_title ? results[i].rich_title : "",
                                "description": results[i].rich_description ? results[i].rich_description : "",
                                "url": results[i].rich_url ? results[i].rich_url : "",
                                "cardHeight": results[i].rich_cardHeight ? results[i].rich_cardHeight : "",
                                "cardOrientation": results[i].rich_cardOrientation ? results[i].rich_cardOrientation : "",
                                "suggestions": SuggestionArr.length ? SuggestionArr : []
                            }
                        ]
                    }


                    // console.log("RICH-CARD", JSON.stringify(finalObj))

                }
                else if (results[i].sub_type == 'carousel') {
                    let newObj = {};
                    Object.keys(results[i]).forEach((ele) => {
                        ele = ele.toString().trim();
                        if (ele.split("_")[0] === "card") newObj[ele] = results[i][ele]
                    });

                    // console.log(newObj, "newobj");
                    let carouselArr = []
                    Array(10).fill(1).forEach((cardEle, idx) => {
                        let card = {};
                        let currentCardFields = Object.keys(newObj).filter(ele => ele.includes("card_" + (idx + 1)));
                        // console.log(currentCardFields, 'fileds');
                        let fieldExceptSuggestion = currentCardFields.filter(ele => !ele.includes('suggestion'));
                        if (currentCardFields.length) {
                            let suggestionArr = []
                            Array(4).fill(1).forEach((sugEle, innerIdx) => {  //  Suggestion level mapping
                                let innerObj = {}
                                let suggestionFields = currentCardFields.filter(ele => ele.includes("card_" + (idx + 1) + "_suggestion_" + (innerIdx + 1)));
                                // console.log(suggestionFields, "suggestion");
                                if (suggestionFields.length) {
                                    suggestionFields.forEach(innerEle => {
                                        innerObj[innerEle.slice(innerEle.lastIndexOf("_") + 1)] = newObj[innerEle]
                                    });
                                    suggestionArr.push(innerObj)
                                };
                            });
                            suggestionArr = suggestionArr.filter(ele => Object.keys(ele).length && Object.values(ele).every(key => key));
                            fieldExceptSuggestion.forEach((cardField) => {
                                card[cardField.slice(cardField.lastIndexOf("_") + 1)] = newObj[cardField]
                            });

                            card["suggestions"] = suggestionArr.length ? suggestionArr : [];
                            carouselArr.push(card)

                        }


                    })
                    carouselArr = carouselArr.filter(ele => Object.keys(ele).length);
                    finalObj["payload"] = {
                        "sub_type": results[i].sub_type ? results[i].sub_type : "",
                        "data": carouselArr
                    }

                    // console.log("CAROUSEL", JSON.stringify(finalObj))

                }

                const TemplateSchema = Joi.object({
                    username: Joi.string().required(),
                    bot_name: Joi.string().required(),
                    name: Joi.string().required(),
                    variables: Joi.array().items(Joi.string()),
                    category: Joi.string().required().valid('text', 'rich'),
                    status: Joi.string(),
                    system_ip: Joi.string().ip({ version: ['ipv4', 'ipv6'] }).required(),
                    payload: Joi.any().required()
                })
                try {
                    const { value, warning } = await TemplateSchema.validate(finalObj);
                    if (warning) continue
                    console.log(value, 'validateData=> ', warning)
                    // templateLogger.info("USER DETAILS", { obj: ` IP : ${get_ip(req).clientIp},"templateData":${JSON.stringify(value)}` });
                    let { status, errMsg } = await createTemplate(value);
                    if (errMsg) {
                        continue;
                    }
                    console.log('errMsg=> ', errMsg, 'stuats=>>', status)
                }
                catch (err) { continue }
               
            }
        });
});


async function createTemplate(info) {
    // console.log(info, "info");

    try {
        const query = await templateModel.create(info);
        // redis.rpush("templateList",query)
        // console.log(query.length, 'query');
        if (query) {
            return { status: true, errMsg: '' };
        }
    } catch (err) {
        // console.log('hiii');
        console.log(err)
        return { status: false, errMsg: err };
    }

}


exports.getTemplate=catchAsync(async (req,res,next)=>{
    let TemplateData;

    //  TemplateData= await redis.lrange('templateList',0,-1);

    console.log(TemplateData)

    if(TemplateData){
        console.log("inside redis database");
         return res.status(200).json({
            message: 'success',
            total:TemplateData.length,
            data: TemplateData
        })
    }else{
        let page = req.query.page;
        let limit = req.query.limit;
        const data= await templateModel.find().skip((page - 1) * limit).limit(limit);
            if(!data){
                return next(new appError('no data found',400));
            }else{
                return res.status(200).json({
                    message: 'success',
                    total:data.length,
                    data: data
                })
            }
        }

    
    });


exports.deleteTemplate=catchAsync(async(req,res,next)=>{
    const id=req.params.id;
    const data= await templateModel.findByIdAndDelete({_id:id});
    if(data){
        return res.status(200).json({
            message:'success',
            data:"Template Delete Successfully!"
        })
    }else{
        return next(new appError('no data found!!',400));
    }
})


6)usercontroller.js

const userModel = require('../model/userModel');

const { validationResult } = require('express-validator');

const bcrypt = require('bcryptjs');

const jwt = require('jsonwebtoken')
const crypto = require('crypto');

const multer = require('multer');

const fs = require('fs')
const csv = require('csv-parser');
const appError = require('../util/appError');
const get_ip = require('ipware')().get_ip;

const nodemailer = require("nodemailer");

const catchAsync = require('../util/catchAsync');

const Email = require('../util/email');

const logger = require('../util/winston');
const twilio = require('twilio');
const client = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

const auth=require('../util/auth');

// const redis=require('../util/redisconnection');



const multiStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'img')
    },
    filename: (req, file, cb) => {
        const ext = file.mimetype.split('/')[1].split('+')[0];
        // console.log(ext,"ext")
        cb(null, `user-${req.user.id}-${Date.now()}.${ext}`);
    }
});

// const multiStorage = multer.memoryStorage();

const multerFilter = (req, file, cb) => {
    if (file.mimetype.startsWith('image')) {
        cb(null, true)
    }
    else {
        cb(new appError('not a image file', 404), false)
    }
}

const upload = multer({
    storage: multiStorage,
    fileFilter: multerFilter
});

exports.uploadPhoto = upload.single('image');


const multiStorageFile = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'public')
    },
    filename: (req, file, cb) => {
        const ext = file.mimetype.split('/')[1];
        cb(null, `userFile.${ext}`);
    }
});


const multerFilterFile = (req, file, cb) => {
    if (file.mimetype == 'text/csv') { // checking the MIME type of the uploaded file
        cb(null, true);
    } else {
        cb(new appError('not a proper file', 400), false);
    }
}

const uploadFile = multer({
    storage: multiStorageFile,
    fileFilter: multerFilterFile

});

exports.uploadFile = uploadFile.single('myFile');



// const creatSendToken = (user, status, res) => {
//     // console.log(res);
//     const token = signToken(user._id, user.name);
//     // res.cookie('jwt', token, cookieOption)

//     //remove the password form the output
//     // user.password = undefined;
//     // user.cnfpassword = undefined;

//     res.status(status).send({
//         status: 'success',
//         token,
//         data: {
//             user
//         }
//     });
// }


// const signToken = (id, name) => {
//     return jwt.sign({ id: id, name: name }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRED });
// }


exports.signUp = catchAsync(async (req, res, next) => {
    // res.send('signup function called')
    const error = validationResult(req);

    if (!error.isEmpty()) {
        // console.log("hiiiii",error.errors[0]?.msg)
        return next(new appError(error.errors[0]?.msg, 422));
    }
    const haspass = await bcrypt.hash(req.body.password, 12)
    req.body.password = haspass;
    req.body.post = [];
    const result = await userModel.create(req.body);
    // redis.rpush("userDetails",result);
    const { clientIp } = get_ip(req);
    logger.info("USER DETAILS", { obj: ` IP : ${clientIp}` });
    // creatSendToken(result, 201, res);
    res.status(201).json({
        message:'success',
        data:"user register successfully!"
    });
})


exports.login = catchAsync(async (req, res, next) => {
    const error = validationResult(req);

    if (!error.isEmpty()) {

        return next(new appError(error.errors[0]?.msg, 422));
    }
    const user = await userModel.findOne({ email: req.body.email });

    if (!user || !await bcrypt.compare(req.body.password, user.password)) {
        return next(new appError('Incorrect Email or Password', 401));
    }
    // creatSendToken(user, 200, res);
    const AccessToken=auth.generateAccessToken(user);
    const RefreshToken=auth.generateRefreshToken(user);
    user.refreshToken=RefreshToken;
    await user.save();
    res.status(200).send({
        status: 'success',
        "AccessToken":AccessToken,
        "RefreshToken":RefreshToken
    });

})

exports.getAllUser = catchAsync(async (req, res, next) => {
    let finaldata;
    //  finaldata=await redis.lrange('userDetails',0,-1);
    console.log(finaldata);

    if (finaldata) {
        console.log('inside redis database');
        res.status(200).json({
            message: 'success',
            total: finaldata.length,
            data: [...finaldata],
            info: process.pid
        })
    } else {
        console.log('inside database query');
        let page = req.query.page;
        let limit = req.query.limit;
        // try {
        const data = await userModel.find().skip((page - 1) * limit).limit(limit);
        if (data) {
            res.status(200).json({
                message: 'success',
                total: data.length,
                data: data,
                info: process.pid
            })
        }

    }

});


exports.deleteUser = catchAsync(async (req, res, next) => {
    let id = req.params.id;
    // try {
    const user = await userModel.findByIdAndDelete(id);
    if (user) {
        res.status(200).json({
            message: 'success',
            data: "user deleted successfully!!"
        })
    } else {
        return next(new appError('user is not present in database', 400));
    }

})


exports.verifyUser = catchAsync(async (req, res, next) => {
    let id = req.params.id;
    const user = await userModel.findByIdAndUpdate(id, {verify:true});
    if (user) {
        res.status(200).json({
            message: 'user verify succeessfully!!!',
           
        });
    } else {

        return next(new appError('user is not present in database', 400));
    }
})



exports.searchUser = catchAsync(async (req, res, next) => {
    console.log(req.query);
    let name = req.query.name;

    if (!name) {
        return next(new appError('please enter name', 400));
    }

    const list = await userModel.find({ username: { $regex: name, $options: 'i' } })
    if (list) {
        res.status(200).json({
            message: 'success',
            total: list.length,
            data: list
        })
    } else {
        return next(new appError('user is not present in database', 400));
    }

});


exports.followUser = catchAsync(async (req, res, next) => {
    let id = req.params.id;

    console.log(id, "iddddd");


    let userTofollow = await userModel.findById(id);
    let currentUser = await userModel.findById(req.user.id);

    if (!userTofollow) {
        return next(new appError('user is not present in database', 400));
    }

    if(!userTofollow.followers.includes(req.user.id)){
        userTofollow.followers.push(req.user.id);
        currentUser.following.push(id);

        await userTofollow.save();
        await currentUser.save();
        res.status(200).json({
            message:'success',
            data:'user follow successfully!'
        })

    }else{
         return next(new appError('user is already followed', 400));
    }
});


exports.unFollow=catchAsync(async (req,res,next)=>{
let id = req.params.id;

let userToUnFollow=await userModel.findById(id);
let currentUser= await userModel.findById(req.user.id);

 if (!userToUnFollow) {
        return next(new appError('user is not present in database', 400));
    }

    if(userToUnFollow.followers.includes(currentUser._id)){
            userToUnFollow.followers=userToUnFollow.followers.filter(id=>{
                id !==currentUser._id;
            });

            currentUser.following=currentUser.following.filter(id=>{
                id !==userToUnFollow._id;
            });

            await userToUnFollow.save();
            await currentUser.save();
            res.status(200).json({
                message:'success',
                data:'user unfollow successfuly!'
            })
    }else{
         return next(new appError('user is already unfollowed', 400));
    }
});


exports.getUserById = catchAsync(async (req, res, next) => {
    let id = req.params.id;

    const user = await userModel.findById(id).populate('post');
    if (user) {
        res.status(200).json({
            message: 'success',
            data: user
        })
    } else {
        return next(new appError('user is not present in database', 400));
    }


});


exports.editUser = catchAsync(async (req, res, next) => {
    let id = req.params.id;
    console.log(req.file, "file")
    // try{
    if (req.file) req.body.photo = req.file.path;
    const user = await userModel.findByIdAndUpdate(id, req.body);
    if (user) {
        res.status(200).json({
            message: 'user updated succeessfully!!!',
            data: user
        });
    } else {

        return next(new appError('user is not present in database', 400));
    }
})


exports.forgotPass = catchAsync(async (req, res, next) => {
    const email = req.body.email;

    const error = validationResult(req);

    if (!error.isEmpty()) {

        return next(new appError(error.errors[0]?.msg, 422));
    }

    // try{
    const user = await userModel.findOne({ email: email });
    if (!user) {

        return next(new appError('user is not present in database', 400));
    } else {
        crypto.randomBytes(32, async (err, buffer) => {
            if (err) {
                res.status(400).json({
                    message: 'error',
                    data: err
                })

            } else {
                let token = buffer.toString('hex');
                user.resetToken = token;
                user.resetTokenExpire = Date.now() + 3600000;
                user.save();
                let url = `visit this url for reset password "http://localhost:3000/api/v1/user/resetPass/${token}"`;
                // sendMail(url,user.email,'Reset password ');
                await new Email(user, url).sendPassReset();
                res.status(200).json({
                    message: 'success',
                    data: url
                })
            }

        })
    }

    // }catch(err){
    //     console.log(err);
    //     res.status(500).json({
    //         message: 'error',
    //         data: err
    //     }); 
    // }

})


exports.resetPass = catchAsync(async (req, res, next) => {
    const token = req.params.token;

    // try{

    if (req.body.password !== req.body.cnfpassword) {
        console.log(true)
        // return res.status(400).json({
        //     message:'password not match'
        // })
        return next(new appError('password not match', 400));
    }

    let user = await userModel.findOne({ resetToken: token, resetTokenExpire: { $gt: Date.now() } });
    if (!user) {
        // res.status(400).json({
        //     message:'error',
        //     data:'user is not present'
        // })
        return next(new appError('user is not present in database', 400));
    } else {
        console.log(user)
        const pass = await bcrypt.hash(req.body.password, 12);
        console.log(pass, "passss")
        // const password= await pass;
        user.password = pass;
        user.resetToken = null;
        user.resetTokenExpire = null;
        user.save();
        console.log("jghdhhjk")
        // creatSendToken(user, 200, res);
         res.status(200).json({
            message:'password reset successfully!!!'
        })
    }
    //  }catch(err){
    //     res.status(500).json({
    //         message: 'error',
    //         data: err
    //     }); 
    // }
});

let results = [];

exports.createBulkUser = async (req, res, next) => {
    results = [];

    fs.createReadStream(req.file.path)
        .pipe(csv({}))
        .on('data', (data) => {
            console.log(data, "datatatatat")
            results.push(data);

        })
        .on('end', async () => {

            for (let i = 0; i < results.length; i++) {
                console.log(results[i], "resesd")

                let { status, errMsg } = await createUser(results[i]);
                if (status) {
                    if (results.length - 1 == i) {
                        return res.status(201).send({ message: "all created" })
                    }
                } else {
                    res.status(500).send({ message: errMsg });
                    break;
                }
            }



        });



}

exports.restrictTo = (...roles) => {
    return (req, res, next) => {
        console.log(req.user,"this is error")
        if (!roles.includes(req.user.role)) {
            return next(new appError('you dont have permission to perform this action', 403));
        }
        next()
    }
}

async function createUser(info) {

    try {
        console.log(info, "infoooo")
        let pass = info.password;
        info.password = await bcrypt.hash(info.password, 12);
        const query = await userModel.create(info);
        let msg = `user register successfully !!
        your username is "${info.email}" and password is "${pass}"
         plz visit this your for login -> "http://localhost:3000/api/v1/user/login"`;
        // sendMail(msg,info.email,'Registration Successfully!!!');
        await new Email(info, msg).sendwelcome();
        if (query) {
            return { status: true, errMsg: '' };
        }
    } catch (err) {
        // console.log(err)
        return { status: false, errMsg: err };
    }

}

exports.generateToken=catchAsync(async (req,res,next)=>{
    //  const { refreshToken } = req.body;

     console.log("generateToken function called here",req.query.refreshToken);
     let refreshToken=req.query.refreshToken;
     
//   if (!refreshToken) return res.sendStatus(401);

   if (!refreshToken) {
        return next(new appError('something went wrong', 401));
    }

  const user = await userModel.findOne({ refreshToken });
//   if (!user) return res.sendStatus(403);

   if (!user) {
        return next(new appError('User not found!', 403));
    }

  jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, (err, decoded) => {
    if (err) return res.sendStatus(403);
    const accessToken = auth.generateAccessToken(user);
    res.json({ "accessToken" :accessToken});
  });
});


exports.towFALogin=catchAsync(async (req,res,next)=>{
     const error = validationResult(req);

    if (!error.isEmpty()) {

        return next(new appError(error.errors[0]?.msg, 422));
    }
    const user = await userModel.findOne({ mobile: req.body.mobile});

    if (!user) {
        return next(new appError('Incorrect Mobile No.', 401));
    }

      const otp = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP
    const otpExpires = Date.now() + 5 * 60 * 1000;///expire in 5

    user.otp=otp;
    user.otpExpire=otpExpires;
    await user.save();

     const contact =await client.messages.create({
      body: `Your OTP for login is ${otp}`,
      from: `+1${process.env.TWILIO_PHONE}`,
      to: `+91${req.body.mobile}`
    });

     res.status(200).json({ status: 'success', message: 'OTP sent successfully' });


});



exports.verifyOtp = catchAsync(async (req,res,next)=>{
    const error=validationResult(req);
   if (!error.isEmpty()) {

        return next(new appError(error.errors[0]?.msg, 422));
    }
    const user = await userModel.findOne({ mobile: req.body.mobile });
    if(user.otp !==req.body.otp || user.otpExpire < Date.now()){
        return next(new appError('Invalid or expired OTP', 401));
    }
    user.otp=undefined;
    user.otpExpire=undefined;
    await user.save();
    const AccessToken=auth.generateAccessToken(user);
    const RefreshToken=auth.generateRefreshToken(user);
    user.refreshToken=RefreshToken;
    await user.save();
    res.status(200).send({
        status: 'success',
        "AccessToken":AccessToken,
        "RefreshToken":RefreshToken
    });
});





middleware folder........

1)auth.js

const jwt=require('jsonwebtoken');
const userModel=require('../model/userModel')

exports.token=async(req,res,next)=>{
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  console.log(token);
  
  if (!token) return res.sendStatus(401);

  jwt.verify(token, process.env.JWT_SECRET, async (err, user) => {
    
    if (err) return res.status(403).json({
      message:'token expired'
    });
    console.log(user,"this is user");
    let userData=await userModel.findById(user.id)
    req.user = userData;
    next();
  });
}


model folder..........

1)notificationmodel.js

const mongoose=require('mongoose');

const Schema=mongoose.Schema;

const notificationSchema=new Schema({
     sender:{
            type:Schema.Types.ObjectId,
           ref:'User',
           required:true
        },
        receiver:{
            type:Schema.Types.ObjectId,
           ref:'User',
           required:true
        },
          type: {
        type: String,
        enum: ['like', 'comment', 'follow'],
        required: true
    },
     post:{
            type:Schema.Types.ObjectId,
           ref:'Post',
           required:true
        },
        isRead: { type: Boolean, default: false },
},{ timestamps: true });


module.exports=mongoose.model('Notification',notificationSchema)



2)postmodel.js

const { string, required, ref } = require('joi');
const mongoose=require('mongoose');

const Schema=mongoose.Schema;


const feedModel=new Schema({
    title:{
        type:String,
        required:true,
    },
    imageUrl:{
        type:String,
        required:true
    },
    content:{
            type:String,
            required:true
    },
    creator:{
        type:Schema.Types.ObjectId,
       ref:'User',
       required:true
    },
      visibility: {
        type: String,
        enum: ['public', 'private'],
        default:'public'
    },
    comments:[
        {
        context:{
            type:String,
            required:true
        },
        userId:{
            type:Schema.Types.ObjectId,
            required:true,
            ref:'User'
        }
    }
    ],
    reactions:[
        {
        react:{
            type:String,
            required:true
        },
        userId:{
            type:Schema.Types.ObjectId,
            required:true,
            ref:'User'
        }
    }
    ]

},{timestamps:true});


module.exports=mongoose.model('Post',feedModel);


3)storymodel.js

const { required } = require('joi');
const mongoose=require('mongoose');

const Schema=mongoose.Schema;


const storyModel=new Schema({
    userId:{
          type:Schema.Types.ObjectId,
               ref:'User',
               required:true
    },
    mediaUrl:{
        type:String,
        required:true,

    },
    mediaType:{
        type:String,
        enum: ['image', 'video'],
         default: 'image'
    },
    //  createdAt: { 
    //     type: Date,
    //      default: Date.now 
    //     },
 expiresAt: { 
    type: Date 
}
})

storyModel.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); //  TTL index ensures story auto-deletes after 24 hours.


module.exports=mongoose.model('Story',storyModel);


4)templatemodel.js

const mongoose=require('mongoose');

const schema=mongoose.Schema;

const template=new schema({
    username:{
        type:String,
        required:true
    },
    bot_name:{
        type:String,
        required:true
    },
    name:{
        type:String,
        required:true
    },
    variables:{
        type: [String], // Array of strings
    
    },
    category:{
        type:String,
        required:true
    },
    status:{
        type:String,
        required:true
    },
    system_ip:{
        type:String,
        required:true
    },
    payload:{
        type:Object
    }

},{timestamps:true})


module.exports=mongoose.model('Template',template)


5)usermodel.js

const { boolean } = require('joi');
const mongoose=require('mongoose')

const schema=mongoose.Schema;

const User=new schema({
    email:{
        type:String,
        required:true,
        unique:true
    },
    password:{
        type:String,
        required:true
    },
    username:{
        type:String,
        required:true,
        unique:true
    },
    photo:{
        type:String
    },
    mobile:{
        type:Number,
        unique:true
    },
    otp:{
            type:Number
    },
    otpExpire:{
        type:Date
    },
    role:{
        type:String,
        required:false
    },
    refreshToken:{
        type:String
    },
    verify:{
        type:Boolean,
        default:false
    },
    resetToken:{
        type:String
    },
    resetTokenExpire:{
        type:Date
    },

    post:[
        {
            type:schema.Types.ObjectId,
            ref:'Post'
        }
    ],

     followers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    following: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }]
},{timestamps:true});


module.exports=mongoose.model('User',User)



router folder................


1)notificationRouter.js

const express=require('express');

const router=express.Router();

const auth=require('../middleware/auth');
const {body}=require('express-validator');

const notificationController=require('../controller/notificationController');

router.get('/',auth.token,notificationController.getNotification).patch('/read/:id',auth.token,notificationController.markAsRead)


module.exports=router;


2)postrouter.js

const express=require('express');

const router=express.Router();

const postController=require('../controller/postController');

const auth=require('../middleware/auth');
const {body}=require('express-validator');


router.post('/createPost',[body('title').trim().isLength({min:5}).withMessage('plz enter valid data'),body('content').trim().isLength({min:5}).withMessage('plz enter valid data')],auth.token,postController.createPost)

.get('/getAllPost',auth.token,postController.getAllpost)

.get('/singlePost/:id',auth.token,postController.getSinglePost)

.delete('/delete/:id',auth.token,postController.deletePost)

.patch('/updatePost/:id',auth.token,postController.uploadPostImage,postController.updatePost)


///comments part routes here

.post('/comment/:id',auth.token,postController.comment)




module.exports=router;



3)storyrouter.js

const express=require('express');
const Router=express.Router();

const auth=require('../middleware/auth');
const {body}=require('express-validator');
const parser=require('.././util/multer')

const storyController=require('../controller/storyController')


Router.post('/createStory',auth.token,parser.single('mediaUrl'),storyController.createStory)
.get('/getAllStory',auth.token,storyController.getAllStory)


module.exports=Router;



4) templaterouter.js

const express=require('express');
const templateController=require('../controller/templateController');
const auth=require('../middleware/auth')


const router=express.Router();

router.post('/createTemplate',auth.token,templateController.uploadFile,templateController.createTemplate).get('/getTemplate',auth.token,templateController.getTemplate).delete('/deleteTemplate/:id',auth.token,templateController.deleteTemplate)

module.exports=router;


5)userrouter.js

const express=require('express');
const userController=require('../controller/userController');
const {body}=require('express-validator');
const userModel=require('../model/userModel');

const router=express.Router();

const auth=require('../middleware/auth')  

const parser=require('.././util/multer')

// router.get('/samplecall',userController.sampleCall)

router.post('/signUp',[body('email').isEmail().withMessage('plz enter valid email').custom((value,{req,res})=>{
    return userModel.findOne({email:value}).then(doc=>{
        if(doc){
            console.log("dhdhjdhjk")
            return Promise.reject('User is already Register');
        }
    })
}),body('password').trim().isLength({min:4,max:6}).withMessage('plz enter a valid password'),body('username').trim().notEmpty().withMessage('user name is mandatory'),body('role').trim().notEmpty().withMessage('role is mandotory')],userController.signUp)

.post('/login',[body('email').isEmail().withMessage('plz enter valid email'),body('password').trim().isLength({min:4,max:10}).withMessage('plz enter a valid password')],userController.login)

.get('/getAllUser',auth.token,userController.restrictTo('admin'),userController.getAllUser)

.get('/getUserById/:id',auth.token,userController.getUserById)

.delete('/delete/:id',auth.token,userController.deleteUser)

// .patch('/editUser/:id',auth.token,userController.uploadPhoto,userController.editUser)
.patch('/editUser/:id',auth.token,parser.single('image'),userController.editUser)

.post('/forgotpass',body('email').isEmail().withMessage('plz enter valid email'),userController.forgotPass)

.post('/resetPass/:token',[body('password').trim().isLength({min:4,max:6}).withMessage('plz enter a valid password'),body('cnfpassword').trim()],userController.resetPass)



.post('/createBulk',userController.uploadFile,userController.createBulkUser)

.get('/search',auth.token,userController.searchUser).patch('/follow/:id',auth.token,userController.followUser).patch('/unfollow/:id',auth.token,userController.unFollow)

.post('/token',userController.generateToken)

.post('/verify/:id',auth.token,userController.restrictTo('admin'),userController.verifyUser)


/////opt though login and verify otp

.post('/otp',userController.towFALogin)
.post('/verifyOpt',userController.verifyOtp)



module.exports=router;



util folder....................................................................


1)appError.js

class AppError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
        this.isOperational = true;
        Error.captureStackTrace(this, this.constructor);
    }
}

module.exports = AppError


2)auth.js

const jwt = require("jsonwebtoken");

function generateAccessToken(user) {
  return jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRED });
}

function generateRefreshToken(user) {
  return jwt.sign({ id: user._id }, process.env.REFRESH_TOKEN_SECRET, { expiresIn: process.env.REFRESH_TOKEN_SECRET_EXPIRED });
}

module.exports = { generateAccessToken, generateRefreshToken };


3)catchasync.js

module.exports = fn => {
    return (req, res, next) => {

        fn(req, res, next).catch(next)
    }
}


4)cloudnary.js

// cloudinary.js
const cloudinary = require('cloudinary').v2;
const dotenv = require('dotenv');
dotenv.config();

cloudinary.config({
  cloud_name: process.env.CLOUD_NAME,
  api_key: process.env.CLOUD_API_KEY,
  api_secret: process.env.CLOUD_API_SECRET,
});

module.exports = cloudinary;


5)email.js

const nodemailer = require('nodemailer');

module.exports = class Email {
    constructor(user, url) {
        this.to = user.email,
            this.name = user.name,
            this.url = url,
            this.from = process.env.EMAIL_FROM
    }

    newcreateTransport() {
        if (process.env.NODE_ENV == 'production') {

            //sendgrid
            return 1;
        }

        return nodemailer.createTransport({
            host: process.env.EMAIL_HOST,
            port: process.env.EMAIL_PORT,
            secure: false,
            auth: {
                user: process.env.EMAIL_USERNAME,
                pass: process.env.EMAIL_PASS
            }
        })




    }


    async send(template, subject) {



        const mailOption = {
            from: `"Maddison Foo Koch ðŸ‘»" <${this.from}>`,
            to: this.to,
            subject: subject,
            text: this.url
        }

        this.newcreateTransport();
        await this.newcreateTransport().sendMail(mailOption)

    }

    async sendwelcome() {
        await this.send('welcome', 'Register complete');
    }


    async sendPassReset() {
        await this.send('Password Reset', 'your password reset token will be expire in 10 minute!')
    }

  


}



// module.exports = sendmail;



6)multer.js

// multer.js
const multer = require('multer');
const { CloudinaryStorage } = require('multer-storage-cloudinary');
const cloudinary = require('./cloudnary');

const storage = new CloudinaryStorage({
  cloudinary: cloudinary,
  params: {
    folder: 'uploads', // Folder in Cloudinary
    allowed_formats: ['jpg', 'png', 'jpeg'],
  },
});

const parser = multer({ storage: storage });

module.exports = parser;



7)redisconnection.js

// const redis = require('redis');

// client = redis.createClient();

// client.on('connect', () => {
//     console.log('redis connected')
// })

// client.on('error', (err) => {
//     console.log('something went wrong' + err)
// });



const redis=require('ioredis');

const client=new redis();

module.exports = client;


8)winston.js

var appRoot = require('app-root-path');
const { createLogger, format, transports } = require('winston');
const { combine, timestamp, printf } = format;

const myFormat = printf(info => {
  let message = `\n\n ${info.timestamp} | ${info.level} | ${info.message}`;
  message = info.obj ? message + ` | Data:${JSON.stringify(info.obj)} ` : message
  return message;
});

const logger = createLogger({
  format: combine(
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    myFormat
  ),
  transports: [
    new transports.File({
      filename: `${appRoot}/logs/TemplateLogger.${('0' + (new Date().getMonth() + 1)).slice(-2)}`, 
      level: 'info'
    }),
  ],
  exitOnError: false,
})


module.exports = logger;




****app.js


const express = require('express');
const bodyparser = require('body-parser');

//router here
const userRouter=require('./router/userRouter');
const templateRouter=require('./router/templateRouter');
const postRouter=require('./router/postRouter');
const storyRouter=require('./router/storyRouter');
const notificationRouter=require('./router/notificationRouter');





const compression = require('compression');

const AppErr = require('./util/appError');
const errorController = require('./controller/errorController')
const mongoose = require('mongoose');
const logger=require('./util/winston')
const morgan=require('morgan')
let winston = require('winston');
const app = express();
const path=require('path');
const appRoot = require('app-root-path');
const DailyRotateFile = require("winston-daily-rotate-file");
var expressWinston = require('express-winston');
const ratelimit=require('express-rate-limit');
const helmet=require('helmet');

const xss = require('xss-clean');
const cron = require('node-cron');

const fs = require('fs-extra');

const archiver = require('archiver');

app.use(bodyparser.json());//parsing incoming request body

// url = "mongodb://localhost:27017/userCreation";

///this code is used for cors handling in project
app.use((req, res, next) => {
    res.setHeader('Access-Control-Allow-Origin', '*')
    res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE')
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    next();
});



//limiter api access

const limiter = ratelimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	limit: 100, // Limit each IP to 100 requests per `window` (here, per 15 minutes).
  message:'Too many requests from this IP, please try again in an 15 minutes!'
})

app.use(limiter);
app.use(helmet());
app.use(compression());
app.use(xss());////security purpose sathi
app.use(morgan('combined'));///logs all details of system when api call triggered

app.use('/img',express.static(path.join(__dirname,'img')));

//for template logger
const templateInfo = new winston.transports.DailyRotateFile({
    level: 'warn',
    handleExceptions: false,
    json: true,
    // maxsize: 2 * 15, // no need of fileSize here , now requirement is duration wise
    maxFiles: 6,     // new: requirement to keep 5 zip and  1 fresh file for logs  //old: cuz 1 is older zip and 1 is newly ceated file by winston 
    colorize: false,
    dirname: `${appRoot}/logs/`,
    filename: 'TemplateLogger',
    zippedArchive: true,
    datePattern: "MM"      // for month wise reports 
  })
  
  
  app.use(expressWinston.logger({
    transports: [
      templateInfo,
    ],
    expressFormat: false,
    meta: false,
    format: false
  }))




  ///schedular run here

  const logsDir = path.join(__dirname, 'logs');

  function getZipFilePath() {
  const now = new Date();
  const timestamp = now.toISOString().replace(/[:.]/g, '-');
  return path.join(__dirname, `logs-backup-${timestamp}.zip`);
}

 
// cron.schedule('5 * * * *', async () => {
//   console.log('ðŸ“¦ Zipping logs and cleaning...');

//   const zipPath = getZipFilePath();
//   const output = fs.createWriteStream(zipPath);
//   const archive = archiver('zip', { zlib: { level: 9 } });

//   output.on('close', async () => {
//     console.log(`âœ… Backup zip created: ${zipPath}`);
//     // Delete .log files after zip is done
//     const files = await fs.readdir(logsDir);
//     for (const file of files) {
//       if (file.startsWith('TemplateLogger')) {
//         await fs.remove(path.join(logsDir, file));
//         console.log(`ðŸ—‘ï¸ Deleted: ${file}`);
//       }
//     }
//   });

//   archive.on('error', err => {
//     console.error('âŒ Archive Error:', err);
//   });

//   archive.pipe(output);

//   // Add all .log files
//   const files = await fs.readdir(logsDir);
//   for (const file of files) {
//     if (file.startsWith('TemplateLogger')) {
//       const filePath = path.join(logsDir, file);
//       archive.file(filePath, { name: file });
//     }
//   }

//   archive.finalize();
// });





app.use('/api/v1/user',userRouter);
app.use('/api/v1/template',templateRouter);
app.use('/api/v1/post',postRouter);
app.use('/api/v1/story',storyRouter);
app.use('/api/v1/notification',notificationRouter)

app.all('*', (req, res, next) => {
    next(new AppErr(`cant find ${req.originalUrl} on server`, 404));
});

app.use(errorController)
module.exports=app;


****config.env

NODE_ENV=development


***config.json

{
    "development": {
        "NODE_ENV": "development",
        "USERNAME": "adinath",
        "PASSWORD": 1234,
        "PORT": 3000,
        "DATABASE_LOCAL": "mongodb://localhost:27017/userCreation",
        "JWT_SECRET": "gshjshskjsshjsashashajshskjahsajshaskhsjshskjshkjashkshkjshs",
        "REFRESH_TOKEN_SECRET":"jshkjashkshkjshsgshjshskjsshjsashashajshskjahsajshaskhsjshsk",
       "JWT_EXPIRED": "15m",
        "REFRESH_TOKEN_SECRET_EXPIRED":"7d",
         "TWILIO_ACCOUNT_SID":"ACfe035e31d68a95a0974af963dc692b2b",
        "TWILIO_AUTH_TOKEN":"bc02a262cd1cce2d86fa4acf6fa4bac0",
        "TWILIO_PHONE":"5155795818",
        "JWT_COOKIE_EXPIRES": 90,
        "EMAIL_USERNAME": "lavada.bogan34@ethereal.email",
        "EMAIL_PASS": "mQ5wXzzswktcHAWbg8",
        "EMAIL_HOST": "smtp.ethereal.email",
        "EMAIL_PORT": 587,
        "EMAIL_FROM": "kadamadinath31@gmail.com",
        "CLOUD_NAME":"dfpu50zzm",
"CLOUD_API_KEY":"835725942829653",
"CLOUD_API_SECRET":"31Ny0e8_XmsiCdtyFHQiiFCrlRM"

    },
    "production": {
        "NODE_ENV": "production",
        "USERNAME": "adinath",
        "PASSWORD": 1234,
        "PORT": 3000,
        "DATABASE_LOCAL": "mongodb://localhost:27017/userCreation",
        "JWT_SECRET": "gshjshskjsshjsashashajshskjahsajshaskhsjshskjshkjashkshkjshs",
          "REFRESH_TOKEN_SECRET":"jshkjashkshkjshsgshjshskjsshjsashashajshskjahsajshaskhsjshsk",
        "JWT_EXPIRED": "15m",
        "REFRESH_TOKEN_SECRET_EXPIRED":"7d",
        "TWILIO_ACCOUNT_SID":"ACfe035e31d68a95a0974af963dc692b2b",
        "TWILIO_AUTH_TOKEN":"bc02a262cd1cce2d86fa4acf6fa4bac0",
        "TWILIO_PHONE":"911234567891",
        "JWT_COOKIE_EXPIRES": 90,
        "EMAIL_USERNAME": "ff4ebc7d1602f8",
        "EMAIL_PASS": "50cfd567108e66",
        "EMAIL_HOST": "smtp.mailtrap.io",
        "EMAIL_PORT": 25,
        "EMAIL_FROM": "kadamadinath31@gmail.com",
           "CLOUD_NAME":"dfpu50zzm",
"CLOUD_API_KEY":"835725942829653",
"CLOUD_API_SECRET":"31Ny0e8_XmsiCdtyFHQiiFCrlRM"
    }
}




****docker.dockerignore

node_modules
logs
*.log
.env
config.env
Dockerfile
.dockerignore
.git
.gitignore
.DS_Store



*****dockerfile

FROM node:18
WORKDIR /app
COPY package*.json ./
COPY . /app
COPY . .
COPY config.env ./config.env
RUN npm install
EXPOSE 4000
CMD node server.js




******package.json

{
  "name": "createuserproject",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start:dev": "nodemon server.js",
    "start:prod": "NODE_ENV=production nodemon server.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "app-root-path": "^3.1.0",
    "archiver": "^7.0.1",
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.20.3",
    "cloudinary": "^1.41.3",
    "compression": "^1.8.0",
    "csv-parser": "^3.1.0",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.0",
    "express-winston": "^4.2.0",
    "fs-extra": "^11.3.0",
    "helmet": "^8.0.0",
    "ioredis": "^5.6.0",
    "ipware": "^2.0.0",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.9.1",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "multer-storage-cloudinary": "^4.0.0",
    "node-cron": "^4.1.0",
    "nodemailer": "^6.9.16",
    "pm2": "^5.4.3",
    "redis": "^4.7.0",
    "twilio": "^5.8.0",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^5.0.0",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}




***********server.js

// const dotenv = require('dotenv');
const config = require('./config.json');
const cluster = require('cluster');
const os=require('os');
const totalcpu=os.cpus().length;
const ENV = process.env.NODE_ENV || 'development';
const configData = config[ENV];
for (const property in configData) {
    process.env[property] = configData[property]
}
const mongoose = require('mongoose');



// const redis=require('ioredis');

// const client=new redis();

process.on('uncaughtException', err => {
    console.log('uncaught exception ', err);
    process.exit(1)

});


 


// dotenv.config({ path: './config.env' });
const app = require('./app');
let server;


console.log(cluster.isPrimary);
if(cluster.isPrimary){

    for (let i = 0; i < totalcpu; i++) {
        cluster.fork();
      }
    
      cluster.on('exit', (worker, code, signal) => {
        console.log(`worker ${worker.process.pid} died`);
      });
}else{
    
    mongoose.set('strictQuery', true)//ignore unwanted field from request body that not present in schema
    mongoose.connect(process.env.DATABASE_LOCAL).then(async(con) => {
        console.log('database connected successfully!')
        // const result=await client.get('user:3');
        // console.log(result);
        

        //redis server connect here
        
        server = app.listen(process.env.PORT, () => {
            console.log(`server is running ${process.env.PORT}`);
            console.log(totalcpu);
            
        });
    }).catch(err=>{
        console.log(err);
        
    });

}

// mongoose.set('strictQuery', true)//ignore unwanted field from request body that not present in schema
//     mongoose.connect(process.env.DATABASE_LOCAL).then(con => {
//         console.log('database connected successfully!')
        
//         server = app.listen(process.env.PORT, () => {
//             console.log(`server is running ${process.env.PORT}`);
//             console.log(totalcpu);
            
//         });
//     });



process.on('unhandledRejection', err => {
    console.log(err.name, err.message);
    server.close(() => {
        process.exit(1)

    });
});










